---
title: An Overview of Linux
image: linux.png
img_path: /images/
date: 2023-09-05
categories: [enterprise]
tags: [linux,rhel,terminal]
pin: false
comments: true
---

Everyone has seen a movie where a hacker is typing away on a black screen and code whizzes by. This is our ingrained image a computer super genius. The black screen is something called a terminal which allows you to enter commands that are interpreted directly into programs. Linux is famous for being a terminal heavy operating system, and one hackers and homelabbers alike love to run. Let's take a look at some of the concepts behind Linux.

## Introduction

You could write an entire book on the amount of knowledge there is to cover on Linux - and many people have. For this guide though I just want to cover some of the most basic concepts, and I'll reference material where other people do it better. I'm a big fan of learnlinux.tv as a website. Jay makes absolutely great content for everything linux. Speaking of which, if you've never installed a linux system before, here is his guide on Ubuntu linux so you have a baseline to work with.

{% include youtube.html id='Lj5qHBjSfMo' %}

## Linux Distributions

One of the things I wanted to cover that I found confusing when I first started using linux is the concepts of distributions and streams. Linux comes from the open source community, meaning it was created for free as an operating system. Since it was free and the code was available, many people created their own versions or `forks` of linux. We call these different coding forks distributions. The interesting thing is it didn't stop there. People then forked these distributions, which made forks of forks. When you have a chain of distributions which depend on each other we call this a stream. You can refer to a linux distribution as being `upstream` or `downstream` of another distribution. Let's look at the most famous linux stream as a concrete example.

Redhat Enterprise Linux or RHEL for short, is the de facto enterprise linux distribution. If linux is free you ask, how can a distribution be enterprise? Well, **support** is your answer. RHEL puts features and customer support infrastructure into their product so that they can charge money for a more substantial product. Companies like to know if something breaks someone will stand by it and help them.

Upstream of RHEL sits Fedora, the open source version of RHEL. The community, along with RHEL developers, actively contribute to the Fedora operating system. This code is then used and modified to become RHEL. This coding cycle continues, with one release based off another within the chain. Downstream of RHEL sits several other distributions such as Oracle Linux, Rocky Linux, and Alma Linux. The obvious question would be how can distributions like Rocky Linux take code from RHEL an enterprise version? This is exactly a problem in the linux distribution world. Another distribution, CentOS, used to be the official open-source downstream of RHEL and Rocky and Oracle were based off that. Recently RedHat made very controversial decisions to move CentOS upstream, and no longer make enterprise code available downstream. This has put distributions in a tricky spot where they want to remain 1:1 with RHEL, but struggle to gain insight into RHEL's codebase.

A list of some commonly known Linux distributions sometimes refered to as `flavors`:

- Rocky [https://rockylinux.org/](https://rockylinux.org/): Rocky strives to be a 1:1 downstream clone of RHEL.
- Alma [https://almalinux.org/](https://almalinux.org/): ABI compatible clone of RHEL.
- Oracle [https://www.oracle.com/linux/](https://www.oracle.com/linux/): Oracle's enhanced security Linux downstream of RHEL.
- Fedora [https://fedoraproject.org/](https://fedoraproject.org/): Upstream open-source of RHEL.
- CentOS Stream [https://www.centos.org/](https://www.centos.org/): Positioned midstream between Fedora and RHEL.
- Debian [https://www.debian.org/](https://www.debian.org/): Major RHEL alternative open-source stream which forms Ubuntu. 
- Ubuntu [https://ubuntu.com/](https://ubuntu.com/): Solid linux alternative to RHEL made by Canonical. First choice for a lot of homelabbers and downstream of debian.
- Arch [https://archlinux.org/](https://archlinux.org/): A distro based around constant rolling updates.
- Kali [https://www.kali.org/](https://www.kali.org/): A distro designed around hacking. Popular among penetration testers.

Most of these distros can come with a GUI or they can come as what we refer to as `headless` which basically means terminal only.

## Exploring linux

More to come soon.

## Bash scripting

Automation is one of the keys of linux administration and one of the basic ways to automate a series of commands is a bash script. Here are the basics of making and using a bash script.

Create a script using whatever text editor. For bash scripts we use the `.sh` extension.

```bash
sudo nano script.sh
sudo vi script.sh
```

Paste in

```sh
#!/usr/bin/env bash
#
# Author : Sysblob
# Date: March 2022
# Version 1.0.0: Displays the text "Hello world!"
#

# Displays a text on the screen :
echo "Hello world!"
```

We can then run this bash script by using the bash command.

```bash
bash script.sh
```

We can also give the script proper permissions to be executed and run it directly.

```bash
chmod 775 script.sh
```

Then run it.

```bash
./script.sh
```

Scripts require a full path to execute unless they are added to your path which is why we specify `./` in front. We could also specify `/testdir/script.sh` to run it directly.

> Remember in order to execute scripts you need to give the script execute permissions. Try the command chmod 775 myscript.sh
{: .prompt-warning }

The line `#!/usr/bin/env` bash identifies the binary used to interpret the code. You could also specify the interpreter to be python for example using `#!/usr/bin/env python`.

### Variables

Here is a good script to study to get an idea of how variables work.

```bash
#!/usr/bin/env bash

#
# Author : Sysblob
# Date: July 2023
# Version 1.0.0: Save in /root the files passwd, shadow, group, and gshadow
# Version 1.0.1: Adding what we learned about variables
#

# Global variables
FILE1=/etc/passwd
FILE2=/etc/shadow
FILE3=/etc/group
FILE4=/etc/gshadow

# Destination folder
DESTINATION=/root

## Readonly variables
readonly FILE1 FILE2 FILE3 FILE4 DESTINATION

# A folder name with the day's number
dir="backup-$(date +%j)"

# Clear the screen
clear

# Launch the backup
echo "****************************************************************"
echo "     Backup Script - Backup on ${HOSTNAME}                      "
echo "****************************************************************"
echo "The backup will be made in the folder ${dir}."
echo "Creating the directory..."
mkdir -p ${DESTINATION}/${dir}

echo "Starting the backup of ${FILE1}, ${FILE2}, ${FILE3}, ${FILE4} to ${DESTINATION}/${dir}:"

cp ${FILE1} ${FILE2} ${FILE3} ${FILE4} ${DESTINATION}/${dir}

echo "Backup ended!"

# The backup is noted in the system event log:
logger "Backup of system files by ${USER} on ${HOSTNAME} in the folder ${DESTINATION}/${dir}."
```

### System variables

Some variables come built-in to use:

| Variable      | Description |
| ----------- | ----------- |
| HOSTNAME      | Host name of the machine       |
| PATH   | Path to find the commands        |
| PWD   | Current directory, updated each time the cd command is executed        |
| HOME   | Login directory of user        |
| $$   | Process id of the script execution        |
| $?   | Return code of the last command executed        |
| USER, USERNAME and LOGNAME   | Name of the user connected to the session.       |

We can print environment variables using the `printenv` command or all variables using the `set` command.

```bash
printenv # just global system variables
printenv HOME # Specific variables
set # display all possible variables
```

There are also `Shell variables` which exist inside the current shell session only. Some shell variable commands.

```bash
MY_VAR="text here" # Setting a shell variable
echo $MY_VAR # Print variable
export MY_VAR # Mae shell variable into a permanent global environment variable
export MY_NEW_VAR="My New Var" # Create a shell variable and instantly make it a global environment variable
```
### Permanent variables

Previous mentioned variables are only temporary to your session. To make permanent variables you need to edit some files.

Variables set in the file `/etc/environment` whenever a bash login shell is entered. 

```bash
FOO=bar
VAR_TEST="Test Var"
```

`/etc/profile` Use this file to set up system-wide environment variables.

```bash
export JAVA_HOME="/path/to/java/home"
export PATH=$PATH:$JAVA_HOME/bin
```

If you add new variables make sure to reload them into your current session

```bash
source ~/.bashrc
```

### Storing commands as variables

One other way worth noting to use variables is inserting commands directly into them. The syntax is:

```bash
variable=`command`
variable=$(command) # Preferred syntax
```

Examples below.

```bash
$ day=`date +%d`
$ homedir=$(pwd)
```
